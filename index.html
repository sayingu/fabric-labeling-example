<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Page Title</title>
    <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css"> -->
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"
        integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
    <script src="fabric.min.js"></script>
    <style>
        .canvas-container {
            float: left;
        }
    </style>
</head>

<body>
    <script>
        let canvas = undefined;

        // 각 모드별 정보 변수
        let modeInfo = {
            mode: '',
            rect: {
                strokeColor: 'rgba(255, 0, 0, 0.8)',
                strokeWidth: 10,
                fillColor: 'rgba(255, 0, 0, 0.4)',
                step: 0,
                x: 0,
                y: 0,
                startPoint: null,
                line1: new fabric.Line([0, 0, 0, 0], {
                    strokeWidth: 2,
                    stroke: 'rgba(20, 20, 20, 0.5)'
                }),
                line2: new fabric.Line([0, 0, 0, 0], {
                    strokeWidth: 2,
                    stroke: 'rgba(20, 20, 20, 0.5)'
                })
            },
            poly: {
                strokeColor: 'rgba(255, 0, 0, 0.8)',
                strokeWidth: 10,
                fillColor: 'rgba(255, 0, 0, 0.4)',
                polygonCount: 0,
                circleCount: 1
            },
            brush: {
                strokeColor: 'rgba(255, 0, 0, 0.8)',
                strokeWidth: 10,
                fillColor: 'rgba(255, 0, 0, 0.4)'
            }
        };

        const dap = {
            setCanvasDefaultValues: () => {
                canvas.selection = false;
                canvas.selectionColor = 'rgba(0,255,0,0.3)';
                canvas.selectionBorderColor = 'red';
                canvas.selectionLineWidth = 5;

                // Group controll disable
                fabric.Group.prototype.hasControls = false;

                // Default brush
                canvas.freeDrawingBrush.color = modeInfo.brush.strokeColor;
                canvas.freeDrawingBrush.width = modeInfo.brush.strokeWidth;

                // Set background image
                var imgUrl = 'san-andreas-alexandra-daddario-dwayne-johnson.jpg';
                // var imrUrlTest = 'http://10.155.132.244/sportal/common/file/imageDownload.do?imgId=26663050&1553561167303';
                fabric.Image.fromURL(imgUrl, (img) => {
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                        scaleX: canvas.width / img.width,
                        scaleY: canvas.height / img.height
                    });
                });
            },
            setCanvasSelection: (selection) => {
                canvas.selection = selection;
            },
            createRectangleStartPoint: () => {
                return new fabric.Circle({
                    radius: modeInfo.rect.strokeWidth / 2,
                    fill: modeInfo.rect.strokeColor,
                    left: modeInfo.rect.x,
                    top: modeInfo.rect.y,
                    selectable: false
                });
            },
            createRectangle: (pointer) => {
                return new fabric.Rect({
                    top: modeInfo.rect.y,
                    left: modeInfo.rect.x,
                    width: pointer.x - modeInfo.rect.strokeWidth / 2 - modeInfo.rect.x,
                    height: pointer.y - modeInfo.rect.strokeWidth / 2 - modeInfo.rect.y,
                    stroke: modeInfo.rect.strokeColor,
                    strokeWidth: modeInfo.rect.strokeWidth,
                    fill: modeInfo.rect.fillColor,
                    hasControls: false,
                    borderColor: 'orange',
                    borderWidth: 10
                })
            },
            createPolygonPoint: (pointer) => {
                return new fabric.Circle({
                    left: pointer.x,
                    top: pointer.y,
                    radius: modeInfo.poly.strokeWidth / 2,
                    hasBorders: false,
                    hasControls: false,
                    polygonNo: modeInfo.poly.polygonCount,
                    name: "draggableCircle",
                    circleNo: circleCount,
                    fill: modeInfo.poly.strokeColor,
                    hasRotatingPoint: false,
                    originX: 'center',
                    originY: 'center'
                });
            },
            createPolygon: (points) => {
                return new fabric.Polygon(points, {
                    fill: modeInfo.poly.fillColor,
                    PolygonNumber: modeInfo.poly.polygonCount,
                    name: "Polygon",
                    selectable: false,
                    noofcircles: circleCount - 1,
                    objectCaching: false
                });
            },
            fillBrush: (obj) => {
                obj.dirty = true;
                obj.strokeWidth = modeInfo.brush.strokeWidth;
                obj.fill = modeInfo.brush.fillColor;
            }
        };

        $(document).ready(function () {
            canvas = this.__canvas = new fabric.Canvas('c');

            dap.setCanvasDefaultValues();

            // Just before mouse click event
            canvas.on('mouse:down:before', function (opt) {
                var evt = opt.e;

                if (evt.altKey === true) {
                    canvas.isDrawingMode = false;
                }
            });

            // Mouse click event
            canvas.on('mouse:down', function (opt) {
                var evt = opt.e;

                if (evt.altKey === true) {
                    // 선택 모드
                    canvas.isDragging = true;
                    dap.setCanvasSelection(false);
                    canvas.lastPosX = evt.clientX;
                    canvas.lastPosY = evt.clientY;
                } else {
                    var pointer = canvas.getPointer(evt);

                    // 사각형 모드
                    if (modeInfo.rect.step == 1) {
                        modeInfo.rect.x = pointer.x - modeInfo.rect.strokeWidth / 2;
                        modeInfo.rect.y = pointer.y - modeInfo.rect.strokeWidth / 2;

                        modeInfo.rect.startPoint = dap.createRectangleStartPoint();
                        canvas.add(modeInfo.rect.startPoint);

                        modeInfo.rect.step = 2;
                    } else if (modeInfo.rect.step == 2) {
                        canvas.remove(modeInfo.rect.startPoint);

                        canvas.add(dap.createRectangle(pointer));

                        modeInfo.rect.x = 0;
                        modeInfo.rect.y = 0;
                        modeInfo.rect.step = 0;
                    }

                    // 폴리곤 
                    if (modeInfo.mode == "Polygon") {
                        // 점을 클릭 했을 경우에는 이동을 고려하여 새로운 점을 생성하지 않음
                        if (opt.target && opt.target.type == "circle" && opt.target.name == "draggableCircle") {
                            return;
                        }

                        circle = dap.createPolygonPoint(pointer);
                        canvas.add(circle);
                        circleCount++;

                        // 점이 3개 이상이면 폴리곤 그리기
                        if (circleCount > 3) {
                            var points = [];
                            canvas.getObjects().forEach((obj) => {
                                if (obj.polygonNo === modeInfo.poly.polygonCount) {
                                    points.push({ x: obj.left, y: obj.top });
                                }
                            });

                            if (window["polygon" + modeInfo.poly.polygonCount]) {
                                // 이미 폴리곤이 그려져 있다면 점위치를 추가
                                window["polygon" + modeInfo.poly.polygonCount].set({
                                    points: points
                                });
                            } else {
                                window["polygon" + modeInfo.poly.polygonCount] = dap.createPolygon(points);
                                canvas.add(window["polygon" + modeInfo.poly.polygonCount]);
                                canvas.sendToBack(window["polygon" + modeInfo.poly.polygonCount]);
                            }
                        }
                    }
                }

                canvas.requestRenderAll();
            });

            // Mouse moving event
            canvas.on('mouse:move', function (opt) {
                var evt = opt.e;
                var pointer = canvas.getPointer(evt);

                // 선택 모드
                if (canvas.isDragging) {
                    var zoom = canvas.getZoom();
                    if (zoom > 1) {
                        var x = canvas.viewportTransform[4] + evt.movementX;
                        var y = canvas.viewportTransform[5] + evt.movementY;
                        if (x < 0 && x > canvas.getWidth() - canvas.getWidth() * zoom &&
                            y < 0 && y > canvas.getHeight() - canvas.getHeight() * zoom) {
                            canvas.relativePan(new fabric.Point(evt.movementX, evt.movementY));
                        }
                    }
                }

                if (modeInfo.mode == 'Rectangle') {
                    canvas.setCursor('crosshair');
                    modeInfo.rect.line1.set({ x1: 0, y1: pointer.y, x2: canvas.getWidth(), y2: pointer.y });
                    modeInfo.rect.line2.set({ x1: pointer.x, y1: 0, x2: pointer.x, y2: canvas.getHeight() });
                } else {
                    canvas.setCursor('defaultCursor');
                }

                canvas.requestRenderAll();
            });

            // Mouse clicked event
            canvas.on('mouse:up', function (opt) {
                canvas.isDragging = false;
                if (modeInfo.mode == "Select") {
                    dap.setCanvasSelection(true);
                }

                if (modeInfo.mode == "Brush") {
                    canvas.isDrawingMode = true;
                }

                if ($('input[type=radio][name=rad-mode]:checked').val() == 'Brush') {
                    canvas.getObjects().forEach((obj) => {
                        if (obj.path) {
                            dap.fillBrush(obj);
                        }
                    });
                }

                canvas.requestRenderAll();
            });

            // Mouse wheel event
            canvas.on('mouse:wheel', function (opt) {
                var evt = opt.e;

                var delta = evt.deltaY;
                var zoom = canvas.getZoom();
                zoom = zoom - delta / 200;
                if (zoom > 10) zoom = 10;
                if (zoom < 1) zoom = 1;
                canvas.zoomToPoint({ x: evt.offsetX, y: evt.offsetY }, zoom);

                evt.preventDefault();
                evt.stopPropagation();

                if (canvas.viewportTransform[4] >= 0) {
                    canvas.viewportTransform[4] = 0;
                } else if (canvas.viewportTransform[4] < canvas.getWidth() - canvas.getWidth() * zoom) {
                    canvas.viewportTransform[4] = canvas.getWidth() - canvas.getWidth() * zoom;
                }
                if (canvas.viewportTransform[5] >= 0) {
                    canvas.viewportTransform[5] = 0;
                } else if (canvas.viewportTransform[5] < canvas.getHeight() - canvas.getHeight() * zoom) {
                    canvas.viewportTransform[5] = canvas.getHeight() - canvas.getHeight() * zoom;
                }

                $('#zoom').val((zoom - 1) * 10).siblings('.info').text(Math.round(zoom * 100) + '%');

                canvas.requestRenderAll();
            });

            // Object in canvas select and moving event
            canvas.on('object:moving', function (opt) {
                var target = opt.target;

                switch (target.type) {
                    case 'circle':
                        if (target.name == "draggableCircle") {
                            canvas.forEachObject(function (obj) {
                                if (obj.name == "Polygon") {
                                    if (obj.PolygonNumber == target.polygonNo) {
                                        var points = window["polygon" + target.polygonNo].get("points");
                                        points[target.circleNo - 1].x = target.left;
                                        points[target.circleNo - 1].y = target.top;
                                        window["polygon" + target.polygonNo].set({
                                            points: points
                                        });
                                    }
                                }
                            });
                        }
                        break;
                    case 'activeSelection':
                        var group = target;
                        target.getObjects('circle').forEach((target) => {
                            if (target.name == "draggableCircle") {
                                canvas.forEachObject(function (obj) {
                                    if (obj.name == "Polygon") {
                                        if (obj.PolygonNumber == target.polygonNo) {
                                            var points = window["polygon" + target.polygonNo].get("points");
                                            points[target.circleNo - 1].x = target.left + (group ? group.left + group.width / 2 : 0);
                                            points[target.circleNo - 1].y = target.top + (group ? group.top + group.height / 2 : 0);
                                            window["polygon" + target.polygonNo].set({
                                                points: points
                                            });
                                        }
                                    }
                                });
                            }
                        });
                        break;
                    default:
                        break;
                }

                canvas.requestRenderAll();
            });

            // Selection mode change event
            $('input[type=radio][name=rad-mode]').on('change', function () {
                modeInfo.mode = $('input[type=radio][name=rad-mode]:checked').val();
                modeInfo.rect.step = 0;
                canvas.remove(modeInfo.rect.line1);
                canvas.remove(modeInfo.rect.line2);
                circleCount = 1;
                modeInfo.poly.polygonCount++;
                canvas.isDrawingMode = false;

                switch ($(this).val()) {
                    case 'Select':
                        dap.setCanvasSelection(true);
                        circleCount = 1;
                        modeInfo.poly.polygonCount++;
                        break;
                    case 'Rectangle':
                        dap.setCanvasSelection(false);
                        modeInfo.rect.step = 1;
                        canvas.add(modeInfo.rect.line1);
                        canvas.add(modeInfo.rect.line2);
                        break;
                    case 'Polygon':
                        dap.setCanvasSelection(false);
                        break;
                    case 'Brush':
                        dap.setCanvasSelection(false);
                        canvas.isDrawingMode = true;
                        break;
                    default:
                        break;
                }

                canvas.requestRenderAll();
            });

            // 사각형 모드 라디오
            $('#rad-mode-rect').on('click', function () {
                // TODO 커서를 점 모양으로, 상하좌우 직선 표시
                modeInfo.rect.step = 1;
            });

            // 폴리곤 모드 라디오
            $('#rad-mode-polygon').on('click', function () {
                circleCount = 1;
                modeInfo.poly.polygonCount++;
            });

            // 초기화 버튼
            $('#btn-canvas-clear').on("click", function () {
                canvas.remove(...canvas.getObjects());
                $('input[type=radio][name=rad-mode]:checked').trigger('click');
            })

            // 이미지저장 버튼
            $('#btn-canvas-save').on('click', function () {
                var dataurl = canvas.toDataURL('image/jpeg');
                fetch(dataurl)
                    .then(res => res.blob())
                    .then(blob => {
                        var fd = new FormData();
                        fd.append('image', blob, 'filename');

                        // TODO 업로드
                    });
            });

            // 사각형좌표정보 버튼
            $('#btn-rect-info').on('click', function () {
                var rectObj = canvas.getObjects('rect');
                rectObj.forEach(obj => {
                    alert(`좌상 : ${obj.aCoords.tl}, 우상 : ${obj.aCoords.tr},` +
                        `좌하: ${obj.aCoords.bl}, 우하 : ${obj.aCoords.br}`);
                });

                // TODO 업로드
            });

            // 줌 range input
            $('#zoom').on("change", () => {
                // 배율 변환 후 확대/축소
                var zoomScale = 1 + Number($(this).val()) / 10;
                canvas.zoomToPoint({ x: canvas.getCenter().top, y: canvas.getCenter().left }, zoomScale);

                // 배경이미지를 벗어나지 않도록 위치 조정
                if (canvas.viewportTransform[4] >= 0) {
                    canvas.viewportTransform[4] = 0;
                } else if (canvas.viewportTransform[4] < canvas.getWidth() - canvas.getWidth() * zoomScale) {
                    canvas.viewportTransform[4] = canvas.getWidth() - canvas.getWidth() * zoomScale;
                }
                if (canvas.viewportTransform[5] >= 0) {
                    canvas.viewportTransform[5] = 0;
                } else if (canvas.viewportTransform[5] < canvas.getHeight() - canvas.getHeight() * zoomScale) {
                    canvas.viewportTransform[5] = canvas.getHeight() - canvas.getHeight() * zoomScale;
                }

                // 배율 표시
                $(this).siblings('.info').text(Math.round(zoomScale * 100) + '%');
            });
        });
    </script>
    <div style="float: left;">
        <canvas id="c" width="500" height="500" style="border:1px solid #aaa;"></canvas>

        <div style="display: inline-block; margin-left: 10px; ">
            <label for="zoom">1. Zoom:</label>
            <span class="info">100%</span><input type="range" value="1" min="0" max="90" id="zoom">
            <br />
            <br />

            <label><input type="radio" name="rad-mode" value="Select" checked />
                2. Select<br />
                * Mouse wheel down/up: zoom in/out picture<br />
                * Alt + dragging: move around the picture<br />
                <br />
            </label>
            <label><input type="radio" id="rad-mode-rect" name="rad-mode" value="Rectangle" />
                3. Rectangle<br />
                * first click left, top point<br />
                * second click right, bottom point and make rectangle<br />
                * Radio click again first point will redraw<br />
                <br />
            </label>
            <label><input type="radio" id="rad-mode-polygon" name="rad-mode" value="Polygon" />
                4. Polygon<br />
                * Clicking insert points, then click raiod again make polygon<br />
                <br />
            </label>
            <label><input type="radio" id="rad-mode-brush" name="rad-mode" value="Brush" />5. Brush</label>
            <br />
            <br />

            <button id="btn-canvas-clear">6. Clear</button>
            <br />
            <br />

            <button id="btn-canvas-save">7. Save</button>
            <br />
            <br />

            <button id="btn-rect-info">8. Rectangle info</button>
            <br />
            <br />
        </div>
    </div>
    <div>
        <p>남은거</p>
        <p>1. 네모 선택후 조절은 위치만 되도록 셀렉터 만들기</p>
        <p>펜크기/모양, 색상 조절 기능 추가</p>
        <p>개별 삭제</p>
        <p>브러쉬 지우개 기능 필요</p>
        <p>단축키 정리</p>
        <p>DAP 프로젝트로 이관</p>
    </div>
</body>

</html>